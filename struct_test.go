// WARNING! This is code generated by bindec, do not modify manually.

package bindec

import (
	"bytes"
	"encoding/binary"
	"io"
	"math"
)

var _ = binary.LittleEndian
var _ = math.Abs

// EncodeBinary returns a binary-encoded representation of the type.
func (t StructTestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t StructTestType) WriteBinary(writer io.Writer) error {
	{

		{
			x := t.Int8
			ux := byte(x) << 1
			if x < 0 {
				ux = ^ux
			}
			_, err := writer.Write([]byte{ux})
			if err != nil {
				return err
			}
		}

		{
			x := t.Int16
			ux := uint16(x) << 1
			if x < 0 {
				ux = ^ux
			}
			bs := make([]byte, 2)
			binary.LittleEndian.PutUint16(bs, ux)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			x := t.Int32
			ux := uint32(x) << 1
			if x < 0 {
				ux = ^ux
			}
			bs := make([]byte, 4)
			binary.LittleEndian.PutUint32(bs, ux)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			x := t.Int64
			ux := uint64(x) << 1
			if x < 0 {
				ux = ^ux
			}
			bs := make([]byte, 8)
			binary.LittleEndian.PutUint64(bs, ux)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			x := t.Int
			ux := uint64(x) << 1
			if x < 0 {
				ux = ^ux
			}
			bs := make([]byte, 8)
			binary.LittleEndian.PutUint64(bs, ux)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			if _, err := writer.Write([]byte{t.Byte}); err != nil {
				return err
			}
		}

		{
			if _, err := writer.Write([]byte{t.Uint8}); err != nil {
				return err
			}
		}

		{
			x := t.Uint16
			bs := make([]byte, 2)
			binary.LittleEndian.PutUint16(bs, x)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			x := t.Uint32
			bs := make([]byte, 4)
			binary.LittleEndian.PutUint32(bs, x)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			x := t.Uint64
			bs := make([]byte, 8)
			binary.LittleEndian.PutUint64(bs, x)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			x := t.Uint
			bs := make([]byte, 8)
			binary.LittleEndian.PutUint64(bs, uint64(x))
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			v := t.String
			len := len(v)
			ux := uint64(len) << 1
			if len < 0 {
				ux = ^ux
			}
			sz := make([]byte, 8)
			binary.LittleEndian.PutUint64(sz, ux)
			if _, err := writer.Write(sz); err != nil {
				return err
			}

			_, err := writer.Write([]byte(v))
			if err != nil {
				return err
			}
		}

		{
			bs := make([]byte, 4)
			binary.LittleEndian.PutUint32(bs, math.Float32bits(t.Float32))
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			bs := make([]byte, 8)
			binary.LittleEndian.PutUint64(bs, math.Float64bits(t.Float64))
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			var v byte
			if t.Bool {
				v = 1
			}
			_, err := writer.Write([]byte{v})
			if err != nil {
				return err
			}
		}

		{
			if x := t.Pointer; x == nil {
				if _, err := writer.Write([]byte{0}); err != nil {
					return err
				}
			} else {
				if _, err := writer.Write([]byte{1}); err != nil {
					return err
				}

				{
					var v byte
					if *t.Pointer {
						v = 1
					}
					_, err := writer.Write([]byte{v})
					if err != nil {
						return err
					}
				}

			}
		}

		{
			if x := t.NilPointer; x == nil {
				if _, err := writer.Write([]byte{0}); err != nil {
					return err
				}
			} else {
				if _, err := writer.Write([]byte{1}); err != nil {
					return err
				}

				{
					var v byte
					if *t.NilPointer {
						v = 1
					}
					_, err := writer.Write([]byte{v})
					if err != nil {
						return err
					}
				}

			}
		}

		{
			len := len(t.Slice)
			ux := uint64(len) << 1
			if len < 0 {
				ux = ^ux
			}
			bs := make([]byte, 8)
			binary.LittleEndian.PutUint64(bs, ux)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}

			for i := 0; i < len; i++ {
				x := t.Slice[i]
				ux := uint16(x) << 1
				if x < 0 {
					ux = ^ux
				}
				bs := make([]byte, 2)
				binary.LittleEndian.PutUint16(bs, ux)
				_, err := writer.Write(bs)
				if err != nil {
					return err
				}
			}
		}

		{
			v := t.Bytes
			len := len(v)
			ux := uint64(len) << 1
			if len < 0 {
				ux = ^ux
			}
			sz := make([]byte, 8)
			binary.LittleEndian.PutUint64(sz, ux)
			if _, err := writer.Write(sz); err != nil {
				return err
			}

			_, err := writer.Write(v)
			if err != nil {
				return err
			}
		}

		{
			for i := 0; i < 4; i++ {
				x := t.Array[i]
				ux := uint16(x) << 1
				if x < 0 {
					ux = ^ux
				}
				bs := make([]byte, 2)
				binary.LittleEndian.PutUint16(bs, ux)
				_, err := writer.Write(bs)
				if err != nil {
					return err
				}
			}
		}
		{

			{
				x := t.Struct.Field1
				ux := uint64(x) << 1
				if x < 0 {
					ux = ^ux
				}
				bs := make([]byte, 8)
				binary.LittleEndian.PutUint64(bs, ux)
				_, err := writer.Write(bs)
				if err != nil {
					return err
				}
			}

			{
				v := t.Struct.Flield2
				len := len(v)
				ux := uint64(len) << 1
				if len < 0 {
					ux = ^ux
				}
				sz := make([]byte, 8)
				binary.LittleEndian.PutUint64(sz, ux)
				if _, err := writer.Write(sz); err != nil {
					return err
				}

				_, err := writer.Write([]byte(v))
				if err != nil {
					return err
				}
			}
		}
		{

			{
				x := t.NamedStruct.Field1
				ux := uint64(x) << 1
				if x < 0 {
					ux = ^ux
				}
				bs := make([]byte, 8)
				binary.LittleEndian.PutUint64(bs, ux)
				_, err := writer.Write(bs)
				if err != nil {
					return err
				}
			}

			{
				v := t.NamedStruct.Flield2
				len := len(v)
				ux := uint64(len) << 1
				if len < 0 {
					ux = ^ux
				}
				sz := make([]byte, 8)
				binary.LittleEndian.PutUint64(sz, ux)
				if _, err := writer.Write(sz); err != nil {
					return err
				}

				_, err := writer.Write([]byte(v))
				if err != nil {
					return err
				}
			}
		}

		{
			if x := t.StructPointer; x == nil {
				if _, err := writer.Write([]byte{0}); err != nil {
					return err
				}
			} else {
				if _, err := writer.Write([]byte{1}); err != nil {
					return err
				}

				{

					{
						x := (*t.StructPointer).Field1
						ux := uint64(x) << 1
						if x < 0 {
							ux = ^ux
						}
						bs := make([]byte, 8)
						binary.LittleEndian.PutUint64(bs, ux)
						_, err := writer.Write(bs)
						if err != nil {
							return err
						}
					}

					{
						v := (*t.StructPointer).Flield2
						len := len(v)
						ux := uint64(len) << 1
						if len < 0 {
							ux = ^ux
						}
						sz := make([]byte, 8)
						binary.LittleEndian.PutUint64(sz, ux)
						if _, err := writer.Write(sz); err != nil {
							return err
						}

						_, err := writer.Write([]byte(v))
						if err != nil {
							return err
						}
					}
				}

			}
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *StructTestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *StructTestType) DecodeBinary(reader io.Reader) error {
	{

		{
			var bs = make([]byte, 1)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := bs[0]
			x := int8(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}
			t.Int8 = x
		}

		{
			var bs = make([]byte, 2)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint16(bs)
			x := int16(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}
			t.Int16 = x
		}

		{
			var bs = make([]byte, 4)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint32(bs)
			x := int32(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}
			t.Int32 = x
		}

		{
			var bs = make([]byte, 8)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(bs)
			x := int64(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}
			t.Int64 = x
		}

		{
			var bs = make([]byte, 8)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(bs)
			x := int64(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}
			t.Int = int(x)
		}

		{
			var bs = make([]byte, 1)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}
			t.Byte = bs[0]
		}

		{
			var bs = make([]byte, 1)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}
			t.Uint8 = bs[0]
		}

		{
			var bs = make([]byte, 2)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint16(bs)
			t.Uint16 = ux
		}

		{
			var bs = make([]byte, 4)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint32(bs)
			t.Uint32 = ux
		}

		{
			var bs = make([]byte, 8)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(bs)
			t.Uint64 = ux
		}

		{
			var bs = make([]byte, 8)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(bs)
			t.Uint = uint(ux)
		}

		{
			var sz = make([]byte, 8)
			if _, err := io.ReadFull(reader, sz); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(sz)
			x := int64(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}

			b := make([]byte, int(x))
			if _, err := io.ReadFull(reader, b); err != nil {
				return err
			}

			t.String = string(b)
		}

		{
			var bs = make([]byte, 4)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}
			ux := binary.LittleEndian.Uint32(bs)
			t.Float32 = math.Float32frombits(ux)
		}

		{
			var bs = make([]byte, 8)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}
			ux := binary.LittleEndian.Uint64(bs)
			t.Float64 = math.Float64frombits(ux)
		}

		{
			var v = make([]byte, 1)
			if _, err := io.ReadFull(reader, v); err != nil {
				return err
			}

			t.Bool = v[0] == 1
		}

		{
			var v = make([]byte, 1)
			if _, err := io.ReadFull(reader, v); err != nil {
				return err
			}

			if v[0] == 0 {
				t.Pointer = nil
			} else {
				var tmp_t_Pointer bool

				{
					var v = make([]byte, 1)
					if _, err := io.ReadFull(reader, v); err != nil {
						return err
					}

					tmp_t_Pointer = v[0] == 1
				}

				t.Pointer = &tmp_t_Pointer
			}
		}

		{
			var v = make([]byte, 1)
			if _, err := io.ReadFull(reader, v); err != nil {
				return err
			}

			if v[0] == 0 {
				t.NilPointer = nil
			} else {
				var tmp_t_NilPointer bool

				{
					var v = make([]byte, 1)
					if _, err := io.ReadFull(reader, v); err != nil {
						return err
					}

					tmp_t_NilPointer = v[0] == 1
				}

				t.NilPointer = &tmp_t_NilPointer
			}
		}

		{
			var bs = make([]byte, 8)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(bs)
			x := int64(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}

			len := int(x)

			t.Slice = make([]int16, len)

			for i := 0; i < len; i++ {
				var bs = make([]byte, 2)
				if _, err := io.ReadFull(reader, bs); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint16(bs)
				x := int16(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}
				t.Slice[i] = x
			}
		}

		{
			var sz = make([]byte, 8)
			if _, err := io.ReadFull(reader, sz); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(sz)
			x := int64(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}

			b := make([]byte, int(x))
			if _, err := io.ReadFull(reader, b); err != nil {
				return err
			}

			t.Bytes = b
		}

		{
			for i := 0; i < 4; i++ {
				var bs = make([]byte, 2)
				if _, err := io.ReadFull(reader, bs); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint16(bs)
				x := int16(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}
				t.Array[i] = x
			}
		}
		{

			{
				var bs = make([]byte, 8)
				if _, err := io.ReadFull(reader, bs); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint64(bs)
				x := int64(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}
				t.Struct.Field1 = int(x)
			}

			{
				var sz = make([]byte, 8)
				if _, err := io.ReadFull(reader, sz); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint64(sz)
				x := int64(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}

				b := make([]byte, int(x))
				if _, err := io.ReadFull(reader, b); err != nil {
					return err
				}

				t.Struct.Flield2 = string(b)
			}
		}
		{

			{
				var bs = make([]byte, 8)
				if _, err := io.ReadFull(reader, bs); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint64(bs)
				x := int64(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}
				t.NamedStruct.Field1 = int(x)
			}

			{
				var sz = make([]byte, 8)
				if _, err := io.ReadFull(reader, sz); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint64(sz)
				x := int64(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}

				b := make([]byte, int(x))
				if _, err := io.ReadFull(reader, b); err != nil {
					return err
				}

				t.NamedStruct.Flield2 = string(b)
			}
		}

		{
			var v = make([]byte, 1)
			if _, err := io.ReadFull(reader, v); err != nil {
				return err
			}

			if v[0] == 0 {
				t.StructPointer = nil
			} else {
				var tmp_t_StructPointer Struct2
				{

					{
						var bs = make([]byte, 8)
						if _, err := io.ReadFull(reader, bs); err != nil {
							return err
						}

						ux := binary.LittleEndian.Uint64(bs)
						x := int64(ux >> 1)
						if ux&1 != 0 {
							x = ^x
						}
						tmp_t_StructPointer.Field1 = int(x)
					}

					{
						var sz = make([]byte, 8)
						if _, err := io.ReadFull(reader, sz); err != nil {
							return err
						}

						ux := binary.LittleEndian.Uint64(sz)
						x := int64(ux >> 1)
						if ux&1 != 0 {
							x = ^x
						}

						b := make([]byte, int(x))
						if _, err := io.ReadFull(reader, b); err != nil {
							return err
						}

						tmp_t_StructPointer.Flield2 = string(b)
					}
				}

				t.StructPointer = &tmp_t_StructPointer
			}
		}
	}

	return nil
}
