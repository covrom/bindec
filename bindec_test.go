// WARNING! This is code generated by bindec, do not modify manually.

package bindec

import (
	"bytes"
	"encoding/binary"
	"io"
	"math"
)

var _ = binary.LittleEndian
var _ = math.Abs

// EncodeBinary returns a binary-encoded representation of the type.
func (t StructTestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t StructTestType) WriteBinary(writer io.Writer) error {
	{

		{
			x := int8(t.Int8)
			ux := byte(x) << 1
			if x < 0 {
				ux = ^ux
			}
			_, err := writer.Write([]byte{ux})
			if err != nil {
				return err
			}
		}

		{
			x := int16(t.Int16)
			ux := uint16(x) << 1
			if x < 0 {
				ux = ^ux
			}
			bs := make([]byte, 2)
			binary.LittleEndian.PutUint16(bs, ux)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			x := int32(t.Int32)
			ux := uint32(x) << 1
			if x < 0 {
				ux = ^ux
			}
			bs := make([]byte, 4)
			binary.LittleEndian.PutUint32(bs, ux)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			x := t.Int64
			ux := uint64(x) << 1
			if x < 0 {
				ux = ^ux
			}
			bs := make([]byte, 8)
			binary.LittleEndian.PutUint64(bs, ux)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			x := t.Int
			ux := uint64(x) << 1
			if x < 0 {
				ux = ^ux
			}
			bs := make([]byte, 8)
			binary.LittleEndian.PutUint64(bs, ux)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			if _, err := writer.Write([]byte{byte(t.Byte)}); err != nil {
				return err
			}
		}

		{
			if _, err := writer.Write([]byte{byte(t.Uint8)}); err != nil {
				return err
			}
		}

		{
			x := uint16(t.Uint16)
			bs := make([]byte, 2)
			binary.LittleEndian.PutUint16(bs, x)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			x := uint32(t.Uint32)
			bs := make([]byte, 4)
			binary.LittleEndian.PutUint32(bs, x)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			x := uint64(t.Uint64)
			bs := make([]byte, 8)
			binary.LittleEndian.PutUint64(bs, x)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			x := t.Uint
			bs := make([]byte, 8)
			binary.LittleEndian.PutUint64(bs, uint64(x))
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			v := t.String
			len := len(v)
			ux := uint64(len) << 1
			if len < 0 {
				ux = ^ux
			}
			sz := make([]byte, 8)
			binary.LittleEndian.PutUint64(sz, ux)
			if _, err := writer.Write(sz); err != nil {
				return err
			}

			_, err := writer.Write([]byte(v))
			if err != nil {
				return err
			}
		}

		{
			bs := make([]byte, 4)
			binary.LittleEndian.PutUint32(bs, math.Float32bits(float32(t.Float32)))
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			bs := make([]byte, 8)
			binary.LittleEndian.PutUint64(bs, math.Float64bits(float64(t.Float64)))
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			var v byte
			if t.Bool {
				v = 1
			}
			_, err := writer.Write([]byte{v})
			if err != nil {
				return err
			}
		}

		{
			if x := t.Pointer; x == nil {
				if _, err := writer.Write([]byte{0}); err != nil {
					return err
				}
			} else {
				if _, err := writer.Write([]byte{1}); err != nil {
					return err
				}

				{
					var v byte
					if *t.Pointer {
						v = 1
					}
					_, err := writer.Write([]byte{v})
					if err != nil {
						return err
					}
				}

			}
		}

		{
			if x := t.NilPointer; x == nil {
				if _, err := writer.Write([]byte{0}); err != nil {
					return err
				}
			} else {
				if _, err := writer.Write([]byte{1}); err != nil {
					return err
				}

				{
					var v byte
					if *t.NilPointer {
						v = 1
					}
					_, err := writer.Write([]byte{v})
					if err != nil {
						return err
					}
				}

			}
		}

		{
			len := len(t.Slice)
			ux := uint64(len) << 1
			if len < 0 {
				ux = ^ux
			}
			bs := make([]byte, 8)
			binary.LittleEndian.PutUint64(bs, ux)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}

			for i := 0; i < len; i++ {
				x := int16(t.Slice[i])
				ux := uint16(x) << 1
				if x < 0 {
					ux = ^ux
				}
				bs := make([]byte, 2)
				binary.LittleEndian.PutUint16(bs, ux)
				_, err := writer.Write(bs)
				if err != nil {
					return err
				}
			}
		}

		{
			v := t.Bytes
			len := len(v)
			ux := uint64(len) << 1
			if len < 0 {
				ux = ^ux
			}
			sz := make([]byte, 8)
			binary.LittleEndian.PutUint64(sz, ux)
			if _, err := writer.Write(sz); err != nil {
				return err
			}

			_, err := writer.Write([]byte(v))
			if err != nil {
				return err
			}
		}

		{
			for i := 0; i < 4; i++ {
				x := int16(t.Array[i])
				ux := uint16(x) << 1
				if x < 0 {
					ux = ^ux
				}
				bs := make([]byte, 2)
				binary.LittleEndian.PutUint16(bs, ux)
				_, err := writer.Write(bs)
				if err != nil {
					return err
				}
			}
		}
		{

			{
				x := t.Struct.Field1
				ux := uint64(x) << 1
				if x < 0 {
					ux = ^ux
				}
				bs := make([]byte, 8)
				binary.LittleEndian.PutUint64(bs, ux)
				_, err := writer.Write(bs)
				if err != nil {
					return err
				}
			}

			{
				v := t.Struct.Flield2
				len := len(v)
				ux := uint64(len) << 1
				if len < 0 {
					ux = ^ux
				}
				sz := make([]byte, 8)
				binary.LittleEndian.PutUint64(sz, ux)
				if _, err := writer.Write(sz); err != nil {
					return err
				}

				_, err := writer.Write([]byte(v))
				if err != nil {
					return err
				}
			}
		}
		{

			{
				x := t.NamedStruct.Field1
				ux := uint64(x) << 1
				if x < 0 {
					ux = ^ux
				}
				bs := make([]byte, 8)
				binary.LittleEndian.PutUint64(bs, ux)
				_, err := writer.Write(bs)
				if err != nil {
					return err
				}
			}

			{
				v := t.NamedStruct.Flield2
				len := len(v)
				ux := uint64(len) << 1
				if len < 0 {
					ux = ^ux
				}
				sz := make([]byte, 8)
				binary.LittleEndian.PutUint64(sz, ux)
				if _, err := writer.Write(sz); err != nil {
					return err
				}

				_, err := writer.Write([]byte(v))
				if err != nil {
					return err
				}
			}
		}

		{
			if x := t.StructPointer; x == nil {
				if _, err := writer.Write([]byte{0}); err != nil {
					return err
				}
			} else {
				if _, err := writer.Write([]byte{1}); err != nil {
					return err
				}

				{

					{
						x := (*t.StructPointer).Field1
						ux := uint64(x) << 1
						if x < 0 {
							ux = ^ux
						}
						bs := make([]byte, 8)
						binary.LittleEndian.PutUint64(bs, ux)
						_, err := writer.Write(bs)
						if err != nil {
							return err
						}
					}

					{
						v := (*t.StructPointer).Flield2
						len := len(v)
						ux := uint64(len) << 1
						if len < 0 {
							ux = ^ux
						}
						sz := make([]byte, 8)
						binary.LittleEndian.PutUint64(sz, ux)
						if _, err := writer.Write(sz); err != nil {
							return err
						}

						_, err := writer.Write([]byte(v))
						if err != nil {
							return err
						}
					}
				}

			}
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *StructTestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *StructTestType) DecodeBinary(reader io.Reader) error {
	{

		{
			var bs = make([]byte, 1)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := bs[0]
			x := int8(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}
			t.Int8 = int8(x)
		}

		{
			var bs = make([]byte, 2)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint16(bs)
			x := int16(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}
			t.Int16 = int16(x)
		}

		{
			var bs = make([]byte, 4)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint32(bs)
			x := int32(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}
			t.Int32 = int32(x)
		}

		{
			var bs = make([]byte, 8)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(bs)
			x := int64(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}
			t.Int64 = int64(x)
		}

		{
			var bs = make([]byte, 8)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(bs)
			x := int64(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}
			t.Int = int(x)
		}

		{
			var bs = make([]byte, 1)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}
			t.Byte = byte(bs[0])
		}

		{
			var bs = make([]byte, 1)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}
			t.Uint8 = uint8(bs[0])
		}

		{
			var bs = make([]byte, 2)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint16(bs)
			t.Uint16 = uint16(ux)
		}

		{
			var bs = make([]byte, 4)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint32(bs)
			t.Uint32 = uint32(ux)
		}

		{
			var bs = make([]byte, 8)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(bs)
			t.Uint64 = uint64(ux)
		}

		{
			var bs = make([]byte, 8)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(bs)
			t.Uint = uint(ux)
		}

		{
			var sz = make([]byte, 8)
			if _, err := io.ReadFull(reader, sz); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(sz)
			x := int64(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}

			b := make([]byte, int(x))
			if _, err := io.ReadFull(reader, b); err != nil {
				return err
			}

			t.String = string(b)
		}

		{
			var bs = make([]byte, 4)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}
			ux := binary.LittleEndian.Uint32(bs)
			t.Float32 = float32(math.Float32frombits(ux))
		}

		{
			var bs = make([]byte, 8)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}
			ux := binary.LittleEndian.Uint64(bs)
			t.Float64 = float64(math.Float64frombits(ux))
		}

		{
			var v = make([]byte, 1)
			if _, err := io.ReadFull(reader, v); err != nil {
				return err
			}

			t.Bool = bool(v[0] == 1)
		}

		{
			var v = make([]byte, 1)
			if _, err := io.ReadFull(reader, v); err != nil {
				return err
			}

			if v[0] == 0 {
				t.Pointer = nil
			} else {
				var tmp_t_Pointer bool

				{
					var v = make([]byte, 1)
					if _, err := io.ReadFull(reader, v); err != nil {
						return err
					}

					tmp_t_Pointer = bool(v[0] == 1)
				}

				t.Pointer = &tmp_t_Pointer
			}
		}

		{
			var v = make([]byte, 1)
			if _, err := io.ReadFull(reader, v); err != nil {
				return err
			}

			if v[0] == 0 {
				t.NilPointer = nil
			} else {
				var tmp_t_NilPointer bool

				{
					var v = make([]byte, 1)
					if _, err := io.ReadFull(reader, v); err != nil {
						return err
					}

					tmp_t_NilPointer = bool(v[0] == 1)
				}

				t.NilPointer = &tmp_t_NilPointer
			}
		}

		{
			var bs = make([]byte, 8)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(bs)
			x := int64(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}

			len := int(x)

			t.Slice = make([]int16, len)

			for i := 0; i < len; i++ {
				var bs = make([]byte, 2)
				if _, err := io.ReadFull(reader, bs); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint16(bs)
				x := int16(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}
				(t.Slice)[i] = int16(x)
			}
		}

		{
			var sz = make([]byte, 8)
			if _, err := io.ReadFull(reader, sz); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(sz)
			x := int64(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}

			b := make([]byte, int(x))
			if _, err := io.ReadFull(reader, b); err != nil {
				return err
			}

			t.Bytes = []byte(b)
		}

		{
			for i := 0; i < 4; i++ {
				var bs = make([]byte, 2)
				if _, err := io.ReadFull(reader, bs); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint16(bs)
				x := int16(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}
				(t.Array)[i] = int16(x)
			}
		}
		{

			{
				var bs = make([]byte, 8)
				if _, err := io.ReadFull(reader, bs); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint64(bs)
				x := int64(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}
				t.Struct.Field1 = int(x)
			}

			{
				var sz = make([]byte, 8)
				if _, err := io.ReadFull(reader, sz); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint64(sz)
				x := int64(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}

				b := make([]byte, int(x))
				if _, err := io.ReadFull(reader, b); err != nil {
					return err
				}

				t.Struct.Flield2 = string(b)
			}
		}
		{

			{
				var bs = make([]byte, 8)
				if _, err := io.ReadFull(reader, bs); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint64(bs)
				x := int64(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}
				t.NamedStruct.Field1 = int(x)
			}

			{
				var sz = make([]byte, 8)
				if _, err := io.ReadFull(reader, sz); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint64(sz)
				x := int64(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}

				b := make([]byte, int(x))
				if _, err := io.ReadFull(reader, b); err != nil {
					return err
				}

				t.NamedStruct.Flield2 = string(b)
			}
		}

		{
			var v = make([]byte, 1)
			if _, err := io.ReadFull(reader, v); err != nil {
				return err
			}

			if v[0] == 0 {
				t.StructPointer = nil
			} else {
				var tmp_t_StructPointer Struct2
				{

					{
						var bs = make([]byte, 8)
						if _, err := io.ReadFull(reader, bs); err != nil {
							return err
						}

						ux := binary.LittleEndian.Uint64(bs)
						x := int64(ux >> 1)
						if ux&1 != 0 {
							x = ^x
						}
						tmp_t_StructPointer.Field1 = int(x)
					}

					{
						var sz = make([]byte, 8)
						if _, err := io.ReadFull(reader, sz); err != nil {
							return err
						}

						ux := binary.LittleEndian.Uint64(sz)
						x := int64(ux >> 1)
						if ux&1 != 0 {
							x = ^x
						}

						b := make([]byte, int(x))
						if _, err := io.ReadFull(reader, b); err != nil {
							return err
						}

						tmp_t_StructPointer.Flield2 = string(b)
					}
				}

				t.StructPointer = &tmp_t_StructPointer
			}
		}
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t MapTestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t MapTestType) WriteBinary(writer io.Writer) error {

	{
		len := len(t)
		ux := uint64(len) << 1
		if len < 0 {
			ux = ^ux
		}
		bs := make([]byte, 8)
		binary.LittleEndian.PutUint64(bs, ux)
		_, err := writer.Write(bs)
		if err != nil {
			return err
		}

		for k, v := range t {

			{
				if _, err := writer.Write([]byte{byte(k)}); err != nil {
					return err
				}
			}

			{
				x := uint16(v)
				bs := make([]byte, 2)
				binary.LittleEndian.PutUint16(bs, x)
				_, err := writer.Write(bs)
				if err != nil {
					return err
				}
			}

		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *MapTestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *MapTestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 8)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}

		ux := binary.LittleEndian.Uint64(bs)
		x := int64(ux >> 1)
		if ux&1 != 0 {
			x = ^x
		}

		len := int(x)

		*t = make(MapTestType, len)

		for i := 0; i < len; i++ {
			var key byte
			var value uint16

			{
				var bs = make([]byte, 1)
				if _, err := io.ReadFull(reader, bs); err != nil {
					return err
				}
				key = byte(bs[0])
			}

			{
				var bs = make([]byte, 2)
				if _, err := io.ReadFull(reader, bs); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint16(bs)
				value = uint16(ux)
			}

			(*t)[key] = value
		}
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t ArrayTestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t ArrayTestType) WriteBinary(writer io.Writer) error {

	{
		for i := 0; i < 2; i++ {
			if _, err := writer.Write([]byte{byte(t[i])}); err != nil {
				return err
			}
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *ArrayTestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *ArrayTestType) DecodeBinary(reader io.Reader) error {

	{
		for i := 0; i < 2; i++ {
			var bs = make([]byte, 1)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}
			(*t)[i] = byte(bs[0])
		}
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t SliceTestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t SliceTestType) WriteBinary(writer io.Writer) error {

	{
		len := len(t)
		ux := uint64(len) << 1
		if len < 0 {
			ux = ^ux
		}
		bs := make([]byte, 8)
		binary.LittleEndian.PutUint64(bs, ux)
		_, err := writer.Write(bs)
		if err != nil {
			return err
		}

		for i := 0; i < len; i++ {
			x := uint16(t[i])
			bs := make([]byte, 2)
			binary.LittleEndian.PutUint16(bs, x)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *SliceTestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *SliceTestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 8)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}

		ux := binary.LittleEndian.Uint64(bs)
		x := int64(ux >> 1)
		if ux&1 != 0 {
			x = ^x
		}

		len := int(x)

		*t = make(SliceTestType, len)

		for i := 0; i < len; i++ {
			var bs = make([]byte, 2)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint16(bs)
			(*t)[i] = uint16(ux)
		}
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t ByteTestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t ByteTestType) WriteBinary(writer io.Writer) error {

	{
		if _, err := writer.Write([]byte{byte(t)}); err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *ByteTestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *ByteTestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 1)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}
		*t = ByteTestType(bs[0])
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t Uint16TestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t Uint16TestType) WriteBinary(writer io.Writer) error {

	{
		x := uint16(t)
		bs := make([]byte, 2)
		binary.LittleEndian.PutUint16(bs, x)
		_, err := writer.Write(bs)
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *Uint16TestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *Uint16TestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 2)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}

		ux := binary.LittleEndian.Uint16(bs)
		*t = Uint16TestType(ux)
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t Uint32TestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t Uint32TestType) WriteBinary(writer io.Writer) error {

	{
		x := uint32(t)
		bs := make([]byte, 4)
		binary.LittleEndian.PutUint32(bs, x)
		_, err := writer.Write(bs)
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *Uint32TestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *Uint32TestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 4)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}

		ux := binary.LittleEndian.Uint32(bs)
		*t = Uint32TestType(ux)
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t Uint64TestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t Uint64TestType) WriteBinary(writer io.Writer) error {

	{
		x := uint64(t)
		bs := make([]byte, 8)
		binary.LittleEndian.PutUint64(bs, x)
		_, err := writer.Write(bs)
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *Uint64TestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *Uint64TestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 8)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}

		ux := binary.LittleEndian.Uint64(bs)
		*t = Uint64TestType(ux)
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t UintTestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t UintTestType) WriteBinary(writer io.Writer) error {

	{
		x := t
		bs := make([]byte, 8)
		binary.LittleEndian.PutUint64(bs, uint64(x))
		_, err := writer.Write(bs)
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *UintTestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *UintTestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 8)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}

		ux := binary.LittleEndian.Uint64(bs)
		*t = UintTestType(ux)
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t Int8TestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t Int8TestType) WriteBinary(writer io.Writer) error {

	{
		x := int8(t)
		ux := byte(x) << 1
		if x < 0 {
			ux = ^ux
		}
		_, err := writer.Write([]byte{ux})
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *Int8TestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *Int8TestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 1)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}

		ux := bs[0]
		x := int8(ux >> 1)
		if ux&1 != 0 {
			x = ^x
		}
		*t = Int8TestType(x)
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t Int16TestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t Int16TestType) WriteBinary(writer io.Writer) error {

	{
		x := int16(t)
		ux := uint16(x) << 1
		if x < 0 {
			ux = ^ux
		}
		bs := make([]byte, 2)
		binary.LittleEndian.PutUint16(bs, ux)
		_, err := writer.Write(bs)
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *Int16TestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *Int16TestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 2)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}

		ux := binary.LittleEndian.Uint16(bs)
		x := int16(ux >> 1)
		if ux&1 != 0 {
			x = ^x
		}
		*t = Int16TestType(x)
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t Int32TestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t Int32TestType) WriteBinary(writer io.Writer) error {

	{
		x := int32(t)
		ux := uint32(x) << 1
		if x < 0 {
			ux = ^ux
		}
		bs := make([]byte, 4)
		binary.LittleEndian.PutUint32(bs, ux)
		_, err := writer.Write(bs)
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *Int32TestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *Int32TestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 4)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}

		ux := binary.LittleEndian.Uint32(bs)
		x := int32(ux >> 1)
		if ux&1 != 0 {
			x = ^x
		}
		*t = Int32TestType(x)
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t Int64TestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t Int64TestType) WriteBinary(writer io.Writer) error {

	{
		x := t
		ux := uint64(x) << 1
		if x < 0 {
			ux = ^ux
		}
		bs := make([]byte, 8)
		binary.LittleEndian.PutUint64(bs, ux)
		_, err := writer.Write(bs)
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *Int64TestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *Int64TestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 8)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}

		ux := binary.LittleEndian.Uint64(bs)
		x := int64(ux >> 1)
		if ux&1 != 0 {
			x = ^x
		}
		*t = Int64TestType(x)
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t IntTestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t IntTestType) WriteBinary(writer io.Writer) error {

	{
		x := t
		ux := uint64(x) << 1
		if x < 0 {
			ux = ^ux
		}
		bs := make([]byte, 8)
		binary.LittleEndian.PutUint64(bs, ux)
		_, err := writer.Write(bs)
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *IntTestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *IntTestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 8)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}

		ux := binary.LittleEndian.Uint64(bs)
		x := int64(ux >> 1)
		if ux&1 != 0 {
			x = ^x
		}
		*t = IntTestType(x)
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t UintptrTestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t UintptrTestType) WriteBinary(writer io.Writer) error {

	{
		x := uint64(t)
		bs := make([]byte, 8)
		binary.LittleEndian.PutUint64(bs, x)
		_, err := writer.Write(bs)
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *UintptrTestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *UintptrTestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 8)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}

		ux := binary.LittleEndian.Uint64(bs)
		*t = UintptrTestType(ux)
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t Float32TestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t Float32TestType) WriteBinary(writer io.Writer) error {

	{
		bs := make([]byte, 4)
		binary.LittleEndian.PutUint32(bs, math.Float32bits(float32(t)))
		_, err := writer.Write(bs)
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *Float32TestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *Float32TestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 4)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}
		ux := binary.LittleEndian.Uint32(bs)
		*t = Float32TestType(math.Float32frombits(ux))
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t Float64TestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t Float64TestType) WriteBinary(writer io.Writer) error {

	{
		bs := make([]byte, 8)
		binary.LittleEndian.PutUint64(bs, math.Float64bits(float64(t)))
		_, err := writer.Write(bs)
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *Float64TestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *Float64TestType) DecodeBinary(reader io.Reader) error {

	{
		var bs = make([]byte, 8)
		if _, err := io.ReadFull(reader, bs); err != nil {
			return err
		}
		ux := binary.LittleEndian.Uint64(bs)
		*t = Float64TestType(math.Float64frombits(ux))
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t StringTestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t StringTestType) WriteBinary(writer io.Writer) error {

	{
		v := t
		len := len(v)
		ux := uint64(len) << 1
		if len < 0 {
			ux = ^ux
		}
		sz := make([]byte, 8)
		binary.LittleEndian.PutUint64(sz, ux)
		if _, err := writer.Write(sz); err != nil {
			return err
		}

		_, err := writer.Write([]byte(v))
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *StringTestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *StringTestType) DecodeBinary(reader io.Reader) error {

	{
		var sz = make([]byte, 8)
		if _, err := io.ReadFull(reader, sz); err != nil {
			return err
		}

		ux := binary.LittleEndian.Uint64(sz)
		x := int64(ux >> 1)
		if ux&1 != 0 {
			x = ^x
		}

		b := make([]byte, int(x))
		if _, err := io.ReadFull(reader, b); err != nil {
			return err
		}

		*t = StringTestType(b)
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t BytesTestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t BytesTestType) WriteBinary(writer io.Writer) error {

	{
		v := t
		len := len(v)
		ux := uint64(len) << 1
		if len < 0 {
			ux = ^ux
		}
		sz := make([]byte, 8)
		binary.LittleEndian.PutUint64(sz, ux)
		if _, err := writer.Write(sz); err != nil {
			return err
		}

		_, err := writer.Write([]byte(v))
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *BytesTestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *BytesTestType) DecodeBinary(reader io.Reader) error {

	{
		var sz = make([]byte, 8)
		if _, err := io.ReadFull(reader, sz); err != nil {
			return err
		}

		ux := binary.LittleEndian.Uint64(sz)
		x := int64(ux >> 1)
		if ux&1 != 0 {
			x = ^x
		}

		b := make([]byte, int(x))
		if _, err := io.ReadFull(reader, b); err != nil {
			return err
		}

		*t = BytesTestType(b)
	}

	return nil
}

// EncodeBinary returns a binary-encoded representation of the type.
func (t BoolTestType) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t BoolTestType) WriteBinary(writer io.Writer) error {

	{
		var v byte
		if t {
			v = 1
		}
		_, err := writer.Write([]byte{v})
		if err != nil {
			return err
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *BoolTestType) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *BoolTestType) DecodeBinary(reader io.Reader) error {

	{
		var v = make([]byte, 1)
		if _, err := io.ReadFull(reader, v); err != nil {
			return err
		}

		*t = BoolTestType(v[0] == 1)
	}

	return nil
}
