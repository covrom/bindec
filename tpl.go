package bindec

const methodsTpl = `
// EncodeBinary returns a binary-encoded representation of the type.
func (%[1]s %[2]s) EncodeBinary() ([]byte, error) {
	var w = bytes.NewBuffer(nil)
	if err := %[1]s.WriteBinary(w); err != nil {
		return nil, err
	}
	return w.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (%[1]s %[2]s) WriteBinary(w io.Writer) error {
	%[3]s
	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (%[1]s *%[2]s) DecodeBinaryFromBytes(data []byte) error {
	r := bytes.NewReader(data)
	return %[1]s.DecodeBinary(r)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (%[1]s *%[2]s) DecodeBinary(r io.Reader) error {
	%[4]s
	return nil
}
`

const fileTpl = `
// WARNING! This is code generated by bindec, do not modify manually.

package %[1]s

import (
	%[3]s
)

var _ = binary.LittleEndian
var _ = math.Abs

%[4]s

%[2]s
`

const (
	readString = `
{
	var sz int
	if err := binary.Read(r, binary.LittleEndian, &sz); err != nil {
		return err
	}
	%[4]s

	b := make([]byte, sz)
	if _, err := io.ReadFull(r, b); err != nil {
		return err
	}

	%[3]s%[2]s = %[1]s(b)

	%[5]s
}
`

	writeString = `
{
	v := []byte(%s)
	if err := binary.Write(w, binary.LittleEndian, len(v)); err != nil {
		return err
	}
	_, err := w.Write(v)
	if err != nil {
		return err
	}
}
`

	readBool = `
{
	var v bool
	if err := binary.Read(r, binary.LittleEndian, &v); err != nil {
		return err
	}

	%[3]s%[2]s = %[1]s(v)

	%[4]s
	%[5]s
}
`

	writeBool = `
{
	v := bool(%s)
	if err := binary.Write(w, binary.LittleEndian, v); err != nil {
		return err
	}
}
`

	readInt = `
{
	var v int64
	if err := binary.Read(r, binary.LittleEndian, &v); err != nil {
		return err
	}

	%[3]s%[2]s = %[1]s(v)

	%[4]s
	%[5]s
}
`

	writeInt = `
{
	v := int64(%s)
	if err := binary.Write(w, binary.LittleEndian, v); err != nil {
		return err
	}
}
`

	readUint = `
{
	var v uint64
	if err := binary.Read(r, binary.LittleEndian, &v); err != nil {
		return err
	}

	%[3]s%[2]s = %[1]s(v)

	%[4]s
	%[5]s
}
`

	writeUint = `
{
	v := uint64(%s)
	if err := binary.Write(w, binary.LittleEndian, v); err != nil {
		return err
	}
}
`

	readInt64 = readInt

	writeInt64 = writeInt

	readUintptr = readUint

	writeUintptr = writeUint

	readUint64 = readUint

	writeUint64 = writeUint

	readInt32 = `
{
	var v int32
	if err := binary.Read(r, binary.LittleEndian, &v); err != nil {
		return err
	}

	%[3]s%[2]s = %[1]s(v)

	%[4]s
	%[5]s
}
`

	writeInt32 = `
{
	v := int32(%s)
	if err := binary.Write(w, binary.LittleEndian, v); err != nil {
		return err
	}
}
`

	readUint32 = `
{
	var v uint32
	if err := binary.Read(r, binary.LittleEndian, &v); err != nil {
		return err
	}

	%[3]s%[2]s = %[1]s(v)

	%[4]s
	%[5]s
}
`

	writeUint32 = `
{
	v := uint32(%s)
	if err := binary.Write(w, binary.LittleEndian, v); err != nil {
		return err
	}
}
`

	readInt16 = `
{
	var v int16
	if err := binary.Read(r, binary.LittleEndian, &v); err != nil {
		return err
	}

	%[3]s%[2]s = %[1]s(v)

	%[4]s
	%[5]s
}
`

	writeInt16 = `
{
	v := int16(%s)
	if err := binary.Write(w, binary.LittleEndian, v); err != nil {
		return err
	}
}
`

	readUint16 = `
{
	var v uint16
	if err := binary.Read(r, binary.LittleEndian, &v); err != nil {
		return err
	}

	%[3]s%[2]s = %[1]s(v)

	%[4]s
	%[5]s
}
`

	writeUint16 = `
{
	v := uint16(%s)
	if err := binary.Write(w, binary.LittleEndian, v); err != nil {
		return err
	}
}
`

	readInt8 = `
{
	var v int8
	if err := binary.Read(r, binary.LittleEndian, &v); err != nil {
		return err
	}

	%[3]s%[2]s = %[1]s(v)

	%[4]s
	%[5]s
}
`

	writeInt8 = `
{
	v := int8(%s)
	if err := binary.Write(w, binary.LittleEndian, v); err != nil {
		return err
	}
}
`

	readByte = `
{
	var v uint8
	if err := binary.Read(r, binary.LittleEndian, &v); err != nil {
		return err
	}

	%[3]s%[2]s = %[1]s(v)

	%[4]s
	%[5]s
}
`

	writeByte = `
{
	v := uint8(%s)
	if err := binary.Write(w, binary.LittleEndian, v); err != nil {
		return err
	}
}
`

	readFloat32 = `
{
	var v float32
	if err := binary.Read(r, binary.LittleEndian, &v); err != nil {
		return err
	}

	%[3]s%[2]s = %[1]s(v)

	%[4]s
	%[5]s
}
`

	writeFloat32 = `
{
	v := float32(%s)
	if err := binary.Write(w, binary.LittleEndian, v); err != nil {
		return err
	}
}
`

	readFloat64 = `
{
	var v float64
	if err := binary.Read(r, binary.LittleEndian, &v); err != nil {
		return err
	}

	%[3]s%[2]s = %[1]s(v)

	%[4]s
	%[5]s
}
`

	writeFloat64 = `
{
	v := float64(%s)
	if err := binary.Write(w, binary.LittleEndian, v); err != nil {
		return err
	}
}
`

	readBytes = readString

	writeBytes = writeString
)
