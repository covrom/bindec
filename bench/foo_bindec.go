// WARNING! This is code generated by bindec, do not modify manually.

package bench

import (
	"bytes"
	"encoding/binary"
	"io"
	"math"
)

var _ = binary.LittleEndian
var _ = math.Abs

// EncodeBinary returns a binary-encoded representation of the type.
func (t Foo) EncodeBinary() ([]byte, error) {
	var writer = bytes.NewBuffer(nil)
	if err := t.WriteBinary(writer); err != nil {
		return nil, err
	}
	return writer.Bytes(), nil
}

// WriteBinary writes the binary-encoded representation of the type to the
// given writer.
func (t Foo) WriteBinary(writer io.Writer) error {
	{

		{
			x := t.A
			ux := uint64(x) << 1
			if x < 0 {
				ux = ^ux
			}
			bs := make([]byte, 8)
			binary.LittleEndian.PutUint64(bs, ux)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}
		}

		{
			v := t.B
			len := len(v)
			ux := uint64(len) << 1
			if len < 0 {
				ux = ^ux
			}
			sz := make([]byte, 8)
			binary.LittleEndian.PutUint64(sz, ux)
			if _, err := writer.Write(sz); err != nil {
				return err
			}

			_, err := writer.Write([]byte(v))
			if err != nil {
				return err
			}
		}

		{
			v := t.C
			len := len(v)
			ux := uint64(len) << 1
			if len < 0 {
				ux = ^ux
			}
			sz := make([]byte, 8)
			binary.LittleEndian.PutUint64(sz, ux)
			if _, err := writer.Write(sz); err != nil {
				return err
			}

			_, err := writer.Write(v)
			if err != nil {
				return err
			}
		}
		{

			{
				x := t.D.A
				bs := make([]byte, 8)
				binary.LittleEndian.PutUint64(bs, x)
				_, err := writer.Write(bs)
				if err != nil {
					return err
				}
			}

			{
				v := t.D.B
				len := len(v)
				ux := uint64(len) << 1
				if len < 0 {
					ux = ^ux
				}
				sz := make([]byte, 8)
				binary.LittleEndian.PutUint64(sz, ux)
				if _, err := writer.Write(sz); err != nil {
					return err
				}

				_, err := writer.Write([]byte(v))
				if err != nil {
					return err
				}
			}
		}

		{
			len := len(t.E)
			ux := uint64(len) << 1
			if len < 0 {
				ux = ^ux
			}
			bs := make([]byte, 8)
			binary.LittleEndian.PutUint64(bs, ux)
			_, err := writer.Write(bs)
			if err != nil {
				return err
			}

			for i := 0; i < len; i++ {
				x := t.E[i]
				ux := uint64(x) << 1
				if x < 0 {
					ux = ^ux
				}
				bs := make([]byte, 8)
				binary.LittleEndian.PutUint64(bs, ux)
				_, err := writer.Write(bs)
				if err != nil {
					return err
				}
			}
		}

		{
			for i := 0; i < 2; i++ {
				x := t.F[i]
				ux := uint64(x) << 1
				if x < 0 {
					ux = ^ux
				}
				bs := make([]byte, 8)
				binary.LittleEndian.PutUint64(bs, ux)
				_, err := writer.Write(bs)
				if err != nil {
					return err
				}
			}
		}

		{
			var v byte
			if t.G {
				v = 1
			}
			_, err := writer.Write([]byte{v})
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// DecodeBinaryFromBytes fills the type with the given binary-encoded
// representation of the type.
func (t *Foo) DecodeBinaryFromBytes(data []byte) error {
	var reader = bytes.NewReader(data)
	return t.DecodeBinary(reader)
}

// DecodeBinary reads the binary representation of the type from the given
// reader and fulls the type with it.
func (t *Foo) DecodeBinary(reader io.Reader) error {
	{

		{
			var bs = make([]byte, 8)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(bs)
			x := int64(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}
			t.A = int(x)
		}

		{
			var sz = make([]byte, 8)
			if _, err := io.ReadFull(reader, sz); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(sz)
			x := int64(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}

			b := make([]byte, int(x))
			if _, err := io.ReadFull(reader, b); err != nil {
				return err
			}

			t.B = string(b)
		}

		{
			var sz = make([]byte, 8)
			if _, err := io.ReadFull(reader, sz); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(sz)
			x := int64(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}

			b := make([]byte, int(x))
			if _, err := io.ReadFull(reader, b); err != nil {
				return err
			}

			t.C = b
		}
		{

			{
				var bs = make([]byte, 8)
				if _, err := io.ReadFull(reader, bs); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint64(bs)
				t.D.A = ux
			}

			{
				var sz = make([]byte, 8)
				if _, err := io.ReadFull(reader, sz); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint64(sz)
				x := int64(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}

				b := make([]byte, int(x))
				if _, err := io.ReadFull(reader, b); err != nil {
					return err
				}

				t.D.B = string(b)
			}
		}

		{
			var bs = make([]byte, 8)
			if _, err := io.ReadFull(reader, bs); err != nil {
				return err
			}

			ux := binary.LittleEndian.Uint64(bs)
			x := int64(ux >> 1)
			if ux&1 != 0 {
				x = ^x
			}

			len := int(x)

			t.E = make([]int, len)

			for i := 0; i < len; i++ {
				var bs = make([]byte, 8)
				if _, err := io.ReadFull(reader, bs); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint64(bs)
				x := int64(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}
				t.E[i] = int(x)
			}
		}

		{
			for i := 0; i < 2; i++ {
				var bs = make([]byte, 8)
				if _, err := io.ReadFull(reader, bs); err != nil {
					return err
				}

				ux := binary.LittleEndian.Uint64(bs)
				x := int64(ux >> 1)
				if ux&1 != 0 {
					x = ^x
				}
				t.F[i] = int(x)
			}
		}

		{
			var v = make([]byte, 1)
			if _, err := io.ReadFull(reader, v); err != nil {
				return err
			}

			t.G = v[0] == 1
		}
	}

	return nil
}
